<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç”Ÿæ—¥å¿«æ¨‚ï¼æ‹¼åœ–æŒ‘æˆ°</title>
    <style>
        :root {
            --primary-color: #FF6B6B;
            --secondary-color: #4ECDC4;
            --bg-color: #f7f9fc;
            --text-color: #2d3436;
            --grid-size: 3; /* æ”¹æˆ 3x3 */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow-x: hidden;
            user-select: none; 
            -webkit-user-select: none;
        }

        h1 {
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 5px;
            font-size: 1.8rem;
            text-shadow: 2px 2px 0px white;
        }
        
        p.subtitle {
            margin-top: 0;
            color: #666;
            font-size: 1rem;
            text-align: center;
            margin-bottom: 20px;
        }

        #level-indicator {
            font-size: 1.3rem;
            margin-bottom: 20px;
            font-weight: bold;
            color: var(--secondary-color);
            background: white;
            padding: 8px 25px;
            border-radius: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .game-container {
            background: white;
            padding: 15px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            position: relative;
            width: 90vw;
            max-width: 400px; 
            aspect-ratio: 1 / 1; 
        }

        #puzzle-board {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), 1fr);
            grid-template-rows: repeat(var(--grid-size), 1fr);
            width: 100%;
            height: 100%;
            border: 3px solid var(--secondary-color);
            background-color: #eee;
            gap: 2px;
            box-sizing: border-box;
            border-radius: 8px;
            overflow: hidden;
            touch-action: none; /* å„ªåŒ–ï¼šé˜²æ­¢æ‰‹æ©Ÿæ»‘å‹•æ™‚é é¢æ²å‹• */
        }

        .tile {
            width: 100%;
            height: 100%;
            /* è¨ˆç®—èƒŒæ™¯åœ–å¤§å°ï¼Œç¢ºä¿åˆ‡åœ–æ­£ç¢º */
            background-size: calc(100% * var(--grid-size) + var(--grid-size) * 2px) calc(100% * var(--grid-size) + var(--grid-size) * 2px);
            background-repeat: no-repeat;
            cursor: pointer;
            transition: transform 0.1s ease-in-out;
            position: relative;
        }
        
        .tile:active {
            transform: scale(0.95);
        }

        .tile.empty {
            background: transparent !important;
            cursor: default;
            pointer-events: none;
        }

        /* å‹åˆ©ç•«é¢ */
        #victory-overlay, #final-celebration {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            text-align: center;
            padding: 30px;
            box-sizing: border-box;
        }

        #victory-overlay.active, #final-celebration.active {
            opacity: 1;
            pointer-events: all;
        }

        #victory-overlay h2, #final-celebration h2 {
            color: var(--primary-color);
            font-size: 2.2rem;
            margin-bottom: 20px;
        }
        
        #final-celebration p {
            font-size: 1.2rem;
            line-height: 1.8;
            color: var(--text-color);
        }

        button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 25px;
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            background-color: #3dbdb4;
        }
        
        button.btn-love {
            background-color: var(--primary-color);
        }

    </style>
</head>
<body>

    <h1>ğŸ§© ç”Ÿæ—¥æ‹¼åœ–å¤§æŒ‘æˆ°</h1>
    <p class="subtitle">å°‡é€™äº›ç¾å¥½çš„å›æ†¶æ‹¼å›ä¾†å§ï¼</p>
    <div id="level-indicator">Level 1 / 5</div>

    <div class="game-container">
        <div id="puzzle-board">
            </div>
    </div>

    <div id="victory-overlay">
        <h2>ğŸ‰ æˆåŠŸè§£é–ï¼</h2>
        <p>å¤ªå²å®³äº†ï¼<br>ä¸‹ä¸€å¼µå›æ†¶æ˜¯ä»€éº¼å‘¢ï¼Ÿ</p>
        <button id="next-level-btn">é€²å…¥ä¸‹ä¸€é—œ â¡ï¸</button>
    </div>

    <div id="final-celebration">
        <h2>ğŸ‚ ç”Ÿæ—¥å¿«æ¨‚ï¼ ğŸ‚</h2>
        <p>
            æ‰€æœ‰çš„æ‹¼åœ–éƒ½å®Œæˆäº†ï¼<br>
            ä½ æ“æœ‰å¾ˆå¤šç¾å¥½çš„ç•«é¢è·Ÿå›æ†¶ã€‚<br>
            ä½ çš„æ•…äº‹å¾ˆé•·ï¼Œè€Œæˆ‘å¸Œæœ›æœªä¾†çš„ç¯‡ç« ï¼Œéƒ½èƒ½å’Œä½ ä¸€èµ·å¯«ã€‚<br>
            ç”Ÿæ—¥å¿«æ¨‚ï¼Œæˆ‘çš„ç”·å­©ï¼é¡˜ä½ ä¸€ç›´å¿«æ¨‚ï¼Œä¸€ç›´è‡ªç”±ã€‚<br>
            <br>
            <strong>æ°¸é æ„›ä½ ï¼ğŸ’–</strong>
        </p>
        <button class="btn-love" onclick="location.reload()">å†ç©ä¸€æ¬¡ ğŸ”„</button>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <script>
        const GRID_SIZE = 3; // è¨­å®šç‚º 3x3
        
        // âš ï¸âš ï¸âš ï¸ è«‹åœ¨é€™è£¡è²¼ä¸Šä½ çš„åœ–ç‰‡ç¶²å€ âš ï¸âš ï¸âš ï¸
        const levels = [
            "https://i.postimg.cc/VL5gFMG7/1-png.png",
            "https://i.postimg.cc/gk5DtJ1w/2-png.png",
            "https://i.postimg.cc/fTFKqL19/3-png.png",
            "https://i.postimg.cc/YqV3D9TL/4-png.png",
            "https://i.postimg.cc/tCf5vT8Z/5-png.png"
        ];

        // âœ¨ å„ªåŒ–ï¼šé å…ˆè¼‰å…¥åœ–ç‰‡åŠŸèƒ½ï¼Œé˜²æ­¢åˆ‡æ›é—œå¡æ™‚é–ƒçˆ
        levels.forEach(url => {
            const img = new Image();
            img.src = url;
        });

        let currentLevel = 0;
        let boardState = [];    
        let emptyTileIndex = { row: GRID_SIZE - 1, col: GRID_SIZE - 1 };
        let isSolved = false;

        const boardElement = document.getElementById('puzzle-board');
        const levelText = document.getElementById('level-indicator');
        const victoryOverlay = document.getElementById('victory-overlay');
        const finalCelebration = document.getElementById('final-celebration');
        const nextLevelBtn = document.getElementById('next-level-btn');

        function initGame() {
            victoryOverlay.classList.remove('active');
            isSolved = false;
            levelText.innerText = `Level ${currentLevel + 1} / ${levels.length}`;
            
            if(levels[currentLevel].includes("åœ¨æ­¤è²¼ä¸Š")) {
                // å¦‚æœä½ çš„åœ–ç‰‡ç¶²å€è²¼éŒ¯ï¼Œæœƒè·³å‡ºé€™å€‹æé†’
                alert("âš ï¸ å¯¶è²æé†’ï¼šè«‹è¨˜å¾—æŠŠåœ–ç‰‡ç¶²å€è²¼é€²ç¨‹å¼ç¢¼è£¡é¢å–”ï¼ä¸ç„¶æœƒçœ‹ä¸åˆ°åœ–");
            }

            createBoard();
            // 3x3 æ¯”è¼ƒç°¡å–®ï¼Œç¨å¾®æ‰“äº‚å³å¯
            setTimeout(shuffleBoard, 500);  
        }

        function createBoard() {
            boardElement.innerHTML = '';
            boardState = [];

            for (let row = 0; row < GRID_SIZE; row++) {
                boardState[row] = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    
                    const id = row * GRID_SIZE + col;
                    tile.dataset.id = id;

                    if (row === GRID_SIZE - 1 && col === GRID_SIZE - 1) {
                        tile.classList.add('empty');
                        boardState[row][col] = null;
                        emptyTileIndex = { row, col };
                    } else {
                        tile.style.backgroundImage = `url('${levels[currentLevel]}')`;
                        const bgX = (col / (GRID_SIZE - 1)) * 100;
                        const bgY = (row / (GRID_SIZE - 1)) * 100;
                        tile.style.backgroundPosition = `${bgX}% ${bgY}%`;
                        boardState[row][col] = tile;
                    }
                    // åœ¨æ­¤éšæ®µå…ˆè³¦äºˆé»æ“Šäº‹ä»¶ï¼Œåœ¨ redrawBoard æˆ– checkWin ä¸­ç¦ç”¨
                    tile.onclick = () => moveTileByClick(tile); 
                    boardElement.appendChild(tile);
                }
            }
        }
        
        function moveTileByClick(tile) {
            // ä¿®æ­£ 1: å¦‚æœå·²ç¶“è§£é–‹ï¼Œå‰‡ç›´æ¥è¿”å›ï¼Œä¸åšä»»ä½•æ“ä½œ
            if(isSolved || tile.classList.contains('empty')) return;
            
            let r, c;
            // å°‹æ‰¾è¢«é»æ“Šæ–¹å¡Šçš„åº§æ¨™
            for(let row=0; row<GRID_SIZE; row++){
                for(let col=0; col<GRID_SIZE; col++){
                    if(boardState[row][col] === tile) {
                        r = row;
                        c = col;
                        break;
                    }
                }
            }
            moveTile(r, c);
        }

        function moveTile(row, col) {
            // ä¿®æ­£ 2: å¦‚æœå·²ç¶“è§£é–‹ï¼Œå‰‡ç›´æ¥è¿”å›ï¼Œä¸åšä»»ä½•æ“ä½œ
            if(isSolved) return; 

            const dRow = Math.abs(row - emptyTileIndex.row);
            const dCol = Math.abs(col - emptyTileIndex.col);

            // å¦‚æœåœ¨ç©ºç™½æ ¼æ—é‚Š
            if (dRow + dCol === 1) {
                const tempTile = boardState[row][col];
                boardState[row][col] = null;
                boardState[emptyTileIndex.row][emptyTileIndex.col] = tempTile;
                
                // é‡ç¹ª
                redrawBoard();

                emptyTileIndex = { row: row, col: col };
                checkWin();
            }
        }
        
        function redrawBoard() {
            boardElement.innerHTML = '';
            for(let r=0; r<GRID_SIZE; r++){
                for(let c=0; c<GRID_SIZE; c++){
                    let tile = boardState[r][c];
                    if(!tile) {
                        tile = document.createElement('div');
                        tile.classList.add('tile', 'empty');
                        // ä¿®æ­£ 3: å¦‚æœéŠæˆ²æœªçµæŸï¼Œæ‰å…è¨±é»æ“Š
                        if (!isSolved) {
                            tile.onclick = () => {};
                        }
                    } else {
                        // ä¿®æ­£ 4: æ ¹æ“šéŠæˆ²ç‹€æ…‹è¨­å®šé»æ“Šäº‹ä»¶
                        if (!isSolved) {
                            tile.onclick = () => moveTileByClick(tile);
                        } else {
                            tile.onclick = null; // å‹åˆ©å¾Œç¦æ­¢é»æ“Š
                        }
                    }
                    boardElement.appendChild(tile);
                }
            }
        }

        function shuffleBoard() {
            let moves = 150; // 3x3 ä¸éœ€è¦å¤ªå¤šæ­¥
            let lastMove = -1;
            const interval = setInterval(() => {
                const r = emptyTileIndex.row;
                const c = emptyTileIndex.col;
                const possibleMoves = [];
                
                if (r > 0 && lastMove !== 1) possibleMoves.push({r: r-1, c: c, dir: 0});
                if (r < GRID_SIZE-1 && lastMove !== 0) possibleMoves.push({r: r+1, c: c, dir: 1});
                if (c > 0 && lastMove !== 3) possibleMoves.push({r: r, c: c-1, dir: 2});
                if (c < GRID_SIZE-1 && lastMove !== 2) possibleMoves.push({r: r, c: c+1, dir: 3});

                if (possibleMoves.length === 0) return;
                const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                
                const tempTile = boardState[move.r][move.c];
                boardState[move.r][move.c] = null;
                boardState[r][c] = tempTile;
                emptyTileIndex = { row: move.r, col: move.c };
                lastMove = move.dir;

                if (moves % 5 === 0) redrawBoard();
                
                moves--;
                if (moves <= 0) {
                    clearInterval(interval);
                    redrawBoard();
                }
            }, 10); 
        }

        function checkWin() {
            let correctCount = 0;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const tile = boardState[r][c];
                    if (tile) {
                        const targetId = parseInt(tile.dataset.id);
                        const currentPosId = r * GRID_SIZE + c;
                        if (targetId === currentPosId) correctCount++;
                    }
                }
            }
            
            // 8ç‰‡éƒ½å°äº†
            if (correctCount === (GRID_SIZE * GRID_SIZE) - 1) {
                isSolved = true;
                
                // ä¿®æ­£ 5: å‹åˆ©æ™‚ï¼Œé‡ç¹ªä¸€æ¬¡ï¼Œç¢ºä¿æ‰€æœ‰ç¢ç‰‡é»æ“Šéƒ½è¢«ç¦ç”¨
                redrawBoard(); 

                const emptyTile = document.querySelector('.tile.empty');
                if(emptyTile) {
                    emptyTile.classList.remove('empty');
                    // å¡«å…¥æœ€å¾Œä¸€å¡Šåœ–ç‰‡ï¼Œä½ç½®æ˜¯ 100% 100% (å³ä¸‹è§’)
                    emptyTile.style.backgroundImage = `url('${levels[currentLevel]}')`;
                    emptyTile.style.backgroundPosition = '100% 100%'; 
                    emptyTile.onclick = null; // ç¢ºä¿æœ€å¾Œä¸€å¡Šç¢ç‰‡ä¹Ÿä¸å¯é»æ“Š
                }
                
                setTimeout(() => {
                    launchConfetti();
                    if (currentLevel < levels.length - 1) {
                        // é¡¯ç¤ºå‹åˆ©è¦†è“‹å±¤ï¼Œç­‰å¾…æ‰‹å‹•é»æ“Š
                        victoryOverlay.classList.add('active'); 
                    } else {
                        finalCelebration.classList.add('active');
                        launchBigConfetti();
                    }
                }, 300);
            }
        }

        nextLevelBtn.onclick = () => {
            currentLevel++;
            initGame(); // æ‰‹å‹•é»æ“Šå¾Œæ‰è¼‰å…¥ä¸‹ä¸€é—œ
        };

        function launchConfetti() {
            confetti({ particleCount: 150, spread: 80, origin: { y: 0.6 } });
        }

        function launchBigConfetti() {
            var duration = 3000;
            var end = Date.now() + duration;
            (function frame() {
                confetti({ particleCount: 5, angle: 60, spread: 55, origin: { x: 0 } });
                confetti({ particleCount: 5, angle: 120, spread: 55, origin: { x: 1 } });
                if (Date.now() < end) requestAnimationFrame(frame);
            }());
        }

        window.onload = initGame;
    </script>
</body>
</html>
